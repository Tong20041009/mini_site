<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>丝滑霓虹爱心烟花</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
// 关键：高 DPR 支持
let DPR = Math.max(1, Math.min(4, window.devicePixelRatio || 1));
let W=0, H=0;
function resize(){
  W = window.innerWidth; H = window.innerHeight;
  canvas.style.width = W+'px';
  canvas.style.height = H+'px';
  canvas.width  = Math.floor(W*DPR);
  canvas.height = Math.floor(H*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // 用 CSS 像素作画
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
}
resize(); addEventListener('resize', resize);

// —— 离屏绘制高分辨率爱心精灵（抗锯齿、再缩放更顺滑）——
function makeHeartSprite(size=256){
  const off = document.createElement('canvas');
  off.width = off.height = size;
  const octx = off.getContext('2d');
  octx.translate(size/2, size/2);
  octx.rotate(-Math.PI/4);
  // 渐变+外发光
  const grd = octx.createLinearGradient(-size/2,-size/2,size/2,size/2);
  grd.addColorStop(0,'#ff66ff');
  grd.addColorStop(.5,'#ff2e63');
  grd.addColorStop(1,'#ffa6d1');
  octx.shadowColor = '#ff5aa9';
  octx.shadowBlur = size*0.08;

  octx.fillStyle = grd;
  // 主身方块
  const r = size*0.22;
  octx.beginPath();
  octx.moveTo(-r, -r);
  octx.lineTo( r, -r);
  octx.lineTo( r,  r);
  octx.lineTo(-r,  r);
  octx.closePath();
  octx.fill();
  // 两个圆
  octx.beginPath();
  octx.arc(-r, -r, r, 0, Math.PI*2);
  octx.arc( r, -r, r, 0, Math.PI*2);
  octx.fill();

  return off;
}
const HEART_SPR = makeHeartSprite(256);

// 物理参数
const COLORS = ['#ff2e63','#ff4d6d','#ff66ff','#ff1493','#ff99cc','#ffa6d1'];
const GRAVITY = 900;          // px/s^2
const BG_FADE = 0.15;         // 背景拖影
const HEARTS_PER_BURST = 120; // 每次爆数量
const SIZE_MIN = 22, SIZE_MAX = 42; // 像素
const SPEED_MIN = 300, SPEED_MAX = 650; // 初速度 px/s
const TRAIL_STEPS = 10;       // 拖尾采样更密，连续而非“点点”

let last = performance.now();
let particles = [];

class Particle{
  constructor(x,y,ang,spd,size,color){
    this.x=x; this.y=y;
    this.vx = Math.cos(ang)*spd;
    this.vy = Math.sin(ang)*spd;
    this.size = size;
    this.color = color;
    this.alpha = 1;
    this.fade = 0.6 + Math.random()*0.5; // 每秒衰减
    this.rot = Math.random()*Math.PI*2;
    this.rotv = (Math.random()-0.5)*1.5; // rad/s
    this.trail = [];
  }
  step(dt){ // dt 秒
    // 细分拖尾：插值若干步，避免“马赛克点”
    const sub = TRAIL_STEPS;
    for(let i=0;i<sub;i++){
      const t = dt/sub;
      this.x += this.vx*t;
      this.y += this.vy*t;
      this.vy += GRAVITY*t;
      this.rot += this.rotv*t;
      this.alpha -= this.fade*t;
      this.trail.push({x:this.x,y:this.y,a:this.alpha});
    }
    while(this.trail.length>sub) this.trail.shift();
  }
  draw(g){
    // 设置发光 & 叠加模式更丝滑
    g.globalCompositeOperation = 'screen';
    // 连续拖尾（由淡到浓）
    for(let i=0;i<this.trail.length;i++){
      const t = this.trail[i], k = i/(this.trail.length-1);
      if(t.a<=0) continue;
      g.globalAlpha = Math.max(0, t.a*0.6*k);
      const s = this.size*(0.6+0.5*k);
      g.save();
      g.translate(t.x, t.y);
      g.rotate(this.rot);
      g.drawImage(HEART_SPR, -s/2, -s/2, s, s);
      g.restore();
    }
    // 本体
    if(this.alpha>0){
      g.globalAlpha = this.alpha;
      g.save();
      g.translate(this.x, this.y);
      g.rotate(this.rot);
      g.drawImage(HEART_SPR, -this.size/2, -this.size/2, this.size, this.size);
      g.restore();
    }
    g.globalCompositeOperation = 'source-over';
  }
}

function heartShapeBurst(cx,cy){
  const n = HEARTS_PER_BURST;
  for(let i=0;i<n;i++){
    const t = (i/n)*Math.PI*2;
    const hx = 16*Math.sin(t)**3;
    const hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    const ang = Math.atan2(-hy, hx); // 指向外
    const spd = SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN);
    const size = SIZE_MIN + Math.random()*(SIZE_MAX-SIZE_MIN);
    const color = COLORS[(Math.random()*COLORS.length)|0];
    particles.push(new Particle(cx,cy,ang,spd,size,color));
  }
}
function randomBurst(cx,cy){
  for(let i=0;i<HEARTS_PER_BURST;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = SPEED_MIN + Math.random()*(SPEED_MAX-SPEED_MIN);
    const size = SIZE_MIN + Math.random()*(SIZE_MAX-SIZE_MIN);
    const color = COLORS[(Math.random()*COLORS.length)|0];
    particles.push(new Particle(cx,cy,ang,spd,size,color));
  }
}

canvas.addEventListener('click', e=>{
  const x=e.clientX, y=e.clientY;
  (Math.random()<0.5?heartShapeBurst:randomBurst)(x,y);
});

function loop(now){
  const dt = Math.min(0.03, (now-last)/1000); // 秒，限帧
  last = now;

  // 背景半透明擦除（拖影）
  ctx.globalAlpha = BG_FADE;
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 1;

  particles = particles.filter(p=>p.alpha>0);
  for(const p of particles){ p.step(dt); p.draw(ctx); }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// 自动爆炸
setInterval(()=>{
  const x = Math.random()*W*0.8 + W*0.1;
  const y = Math.random()*H*0.5 + H*0.2;
  (Math.random()<0.6?heartShapeBurst:randomBurst)(x,y);
}, 900);

// 省电模式：长按 2 秒切换
let pressT=0, eco=false;
addEventListener('touchstart',()=>{pressT=Date.now()});
addEventListener('touchend',()=>{
  if(Date.now()-pressT>1800){
    eco=!eco;
    if(eco){
      HEARTS_PER_BURST = 70;
      BG_FADE = 0.25;
    }else{
      HEARTS_PER_BURST = 120;
      BG_FADE = 0.15;
    }
  }
});
</script>
</body>
</html>