<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>全屏爱心烟花 · 升级版</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });

// === 关键：按设备像素比缩放，解决手机上“看起来很小/发虚”的问题 ===
let W = 0, H = 0, DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
function resize(){
  W = window.innerWidth; H = window.innerHeight;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0); // 之后用“CSS像素”绘制
}
resize();
window.addEventListener('resize', resize);

const COLORS = ['#ff2e63','#ff4d6d','#ff6ec7','#ff66ff','#ff1493','#ff99cc','#ff007f'];
const BG_FADE = 0.25;   // 背景拖影强度（0~1）
const HEARTS_PER_BURST = 150; // 每次爆炸数量
const BASE_SIZE = 24;   // 基础尺寸（像素）
const SIZE_VAR  = 22;   // 尺寸浮动
const G = 0.18;         // 重力
const TRAIL = true;     // 开启拖尾

// 绘制“心”路径（0~50 大小）
function drawHeartPath(){
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(0, -3, -3, -3, -3, 0);
  ctx.bezierCurveTo(-3, 3, 0, 5, 0, 8);
  ctx.bezierCurveTo(0, 5, 3, 3, 3, 0);
  ctx.bezierCurveTo(3, -3, 0, -3, 0, 0);
}

class Particle {
  constructor(x, y, size, color, angle, speed){
    this.x = x; this.y = y;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
    this.size = size;
    this.color = color;
    this.alpha = 1;
    this.fade = 0.008 + Math.random()*0.01;
    this.angle = angle + (Math.random()-0.5)*0.6; // 初始随机旋转
    this.rotateSpeed = (Math.random()-0.5)*0.2;
    this.trail = [];
  }
  step(){
    // 轨迹
    if (TRAIL) {
      this.trail.push({x:this.x, y:this.y, a:this.alpha});
      if (this.trail.length > 8) this.trail.shift();
    }
    // 运动
    this.x += this.vx;
    this.y += this.vy;
    this.vy += G;
    this.alpha -= this.fade;
    this.angle += this.rotateSpeed;
  }
  draw(){
    // 拖尾
    if (TRAIL && this.trail.length>1){
      for (let i=0;i<this.trail.length;i++){
        const t = this.trail[i];
        const k = i/this.trail.length;
        ctx.save();
        ctx.globalAlpha = t.a * 0.5 * k;
        ctx.translate(t.x, t.y);
        ctx.rotate(this.angle);
        const s = (this.size * (0.6 + 0.4*k)) / 50;
        ctx.scale(s, s);
        drawHeartPath();
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 12;
        ctx.fill();
        ctx.restore();
      }
    }
    // 本体
    ctx.save();
    ctx.globalAlpha = this.alpha;
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.scale(this.size/50, this.size/50);
    drawHeartPath();
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 24; // 更亮的光晕
    ctx.fill();
    ctx.restore();
  }
}

let particles = [];

// 生成“心形轮廓”的爆炸（更有辨识度）
function burstHeartShape(cx, cy){
  const R = Math.min(W, H) * 0.25;
  for (let i=0;i<HEARTS_PER_BURST;i++){
    const t = (i / HEARTS_PER_BURST) * Math.PI * 2;
    // 心形参数方程（x = 16 sin^3 t, y = ...）做个归一化
    const hx = 16*Math.sin(t)**3;
    const hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
    const nx = hx/16, ny = -hy/17; // 归一化并翻转 y
    const angle = Math.atan2(ny, nx);
    const speed = 6 + Math.random()*2.5;
    const size = BASE_SIZE + Math.random()*SIZE_VAR; // 24~46 像素
    const color = COLORS[(Math.random()*COLORS.length)|0];
    particles.push(new Particle(cx, cy, size, color, angle, speed));
  }
}

// 随机普通爆炸（补充满屏效果）
function burstRandom(cx, cy){
  for (let i=0;i<HEARTS_PER_BURST;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = 3 + Math.random()*5;
    const size  = BASE_SIZE + Math.random()*SIZE_VAR;
    const color = COLORS[(Math.random()*COLORS.length)|0];
    particles.push(new Particle(cx, cy, size, color, angle, speed));
  }
}

canvas.addEventListener('click', e => {
  const x = e.clientX, y = e.clientY;
  burstHeartShape(x, y);
  if (Math.random() < 0.6) burstRandom(x, y);
});

function loop(){
  // 背景半透明擦除 → 留拖影
  ctx.fillStyle = `rgba(0,0,0,${BG_FADE})`;
  ctx.fillRect(0,0,W,H);

  particles = particles.filter(p=>p.alpha>0);
  for (const p of particles){ p.step(); p.draw(); }
  requestAnimationFrame(loop);
}
loop();

// 自动随机爆炸
setInterval(()=>{
  const x = Math.random()*W*0.8 + W*0.1;
  const y = Math.random()*H*0.5 + H*0.2;
  (Math.random()<0.5 ? burstHeartShape : burstRandom)(x,y);
}, 900);
</script>
</body>
</html>