 <!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>跳动的爱心 · Canvas</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
const cvs = document.getElementById('cv');
const ctx = cvs.getContext('2d', { alpha:false });

// 适配高清屏
function resize(){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
  cvs.style.width = innerWidth + 'px';
  cvs.style.height = innerHeight + 'px';
  cvs.width = Math.floor(innerWidth * dpr);
  cvs.height= Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

// 颜色
const COLOR = '#ff2168';

// 心形参数方程（与 Python 版一致）
function heart(t, scale){
  let x = 16 * Math.sin(t)**3;
  let y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
  x *= scale; y *= scale;
  x += innerWidth/2; y += innerHeight/2;
  return [x,y];
}

// 随机向中心收缩
function scatter(x,y,beta){
  const cx=innerWidth/2, cy=innerHeight/2;
  const rx = -beta * Math.log(Math.random()+1e-6);
  const ry = -beta * Math.log(Math.random()+1e-6);
  return [x - rx*(x-cx), y - ry*(y-cy)];
}

// 帧相关的轻推（心跳）
function pushOut(x,y,ratio){
  const cx=innerWidth/2, cy=innerHeight/2;
  const dx=x-cx, dy=y-cy;
  const force = 1 / (Math.pow(dx*dx+dy*dy, 0.52)+1e-6);
  x -= ratio * force * dx + (Math.random()*2-1);
  y -= ratio * force * dy + (Math.random()*2-1);
  return [x,y];
}

// 预生成点集
const basePoints = new Set();
const edgePoints = [];
const centerPoints = [];
function build(){
  basePoints.clear(); edgePoints.length=0; centerPoints.length=0;
  for(let i=0;i<2000;i++){
    const t = Math.random()*Math.PI*2;
    basePoints.add(heart(t, 11));
  }
  for(const p of basePoints){
    for(let k=0;k<3;k++){
      edgePoints.push(scatter(p[0],p[1],0.05));
    }
  }
  const arr = Array.from(basePoints);
  for(let i=0;i<4000;i++){
    const p = arr[(Math.random()*arr.length)|0];
    centerPoints.push(scatter(p[0],p[1],0.17));
  }
}
build();

let frame=0, last=performance.now();
function loop(now){
  const dt = Math.min(0.03, (now-last)/1000); last=now;
  frame++;

  // 背景：半透明擦除 → 留拖影
  ctx.globalAlpha=0.25; ctx.fillStyle='#000'; ctx.fillRect(0,0,innerWidth,innerHeight);
  ctx.globalAlpha=1;

  // 心跳强度（随帧起伏）
  const ratio = 10 + Math.sin(frame/10)*10;

  ctx.fillStyle = COLOR;
  ctx.shadowColor = COLOR;
  ctx.shadowBlur = 12;

  // 光晕
  const haloR = Math.floor(4 + 6*(1+Math.abs(Math.sin(frame/10))));
  const haloN = Math.floor(3000 + 4000*Math.pow(Math.sin(frame/10)**2,1));
  for(let i=0;i<haloN;i++){
    const t = Math.random()*Math.PI*2;
    let [x,y] = heart(t, 11.6);
    // 收缩到边缘附近
    // 简化版 shrink
    const cx=innerWidth/2, cy=innerHeight/2;
    const dx=x-cx, dy=y-cy;
    const force = 1 / (Math.pow(dx*dx+dy*dy, 0.6)+1e-6);
    x -= haloR*force*dx + (Math.random()*28-14);
    y -= haloR*force*dy + (Math.random()*28-14);
    const s = Math.random()<0.33?2:1;
    ctx.fillRect(x,y,s,s);
  }

  // 原始+扩散点
  function drawSet(list){
    for(let i=0;i<list.length;i++){
      let [x,y] = list[i];
      [x,y] = pushOut(x,y,ratio);
      const s = Math.random()<0.5?1:2;
      ctx.fillRect(x,y,s,s);
    }
  }
  drawSet(Array.from(basePoints));
  drawSet(edgePoints);
  drawSet(centerPoints);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>