<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>跳动的爱心 · Canvas v2</title>
<style>
  html,body{height:100%;margin:0;background:#3b0018;overflow:hidden} /* 深红背景 */
  canvas{display:block}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
const cvs = document.getElementById('cv');
const ctx = cvs.getContext('2d', { alpha:false });

// ---------- 尺寸 & 高清屏适配 ----------
function resize(){
  const dpr = Math.max(1, Math.min(2.5, devicePixelRatio||1));
  const w = innerWidth, h = innerHeight;
  cvs.style.width = w+'px'; cvs.style.height = h+'px';
  cvs.width = Math.floor(w*dpr); cvs.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

// ---------- 配色 & 效果 ----------
const COLOR = '#ff2b7f';
ctx.globalCompositeOperation = 'lighter';

// ---------- 心形参数方程（修正：Y 取反 → 正方向） ----------
function heart(t, scale){
  let x = 16 * Math.sin(t)**3;
  let y = -(13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)); // ← 取反
  x *= scale; y *= scale;
  x += innerWidth/2; y += innerHeight/2;
  return [x,y];
}

// 随机向中心收缩
function scatter(x,y,beta){
  const cx=innerWidth/2, cy=innerHeight/2;
  const rx = -beta * Math.log(Math.random()+1e-6);
  const ry = -beta * Math.log(Math.random()+1e-6);
  return [x - rx*(x-cx), y - ry*(y-cy)];
}

// 帧相关的轻推（心跳）
function pushOut(x,y,ratio){
  const cx=innerWidth/2, cy=innerHeight/2;
  const dx=x-cx, dy=y-cy;
  const force = 1 / (Math.pow(dx*dx+dy*dy, 0.52)+1e-6);
  x -= ratio * force * dx + (Math.random()*2-1);
  y -= ratio * force * dy + (Math.random()*2-1);
  return [x,y];
}

// ---------- 预生成粒子（自适应数量，不卡） ----------
const basePts=[], edgePts=[], centerPts=[], haloPts=[];
function build(){
  basePts.length = edgePts.length = centerPts.length = haloPts.length = 0;

  const shortSide = Math.min(innerWidth, innerHeight);
  const scale = shortSide / 40;              // 心形缩放
  const density = shortSide < 700 ? 1.0 : 1.3;// 平板/大屏更密一点

  const N_base   = Math.floor(1200 * density);
  const N_edge   = Math.floor(1600 * density);
  const N_center = Math.floor(1600 * density);
  const N_halo   = Math.floor(1400 * density);

  for(let i=0;i<N_base;i++){
    const t = Math.random()*Math.PI*2;
    basePts.push(heart(t, scale*1.1));
  }
  for(const p of basePts){
    if(edgePts.length >= N_edge) break;
    for(let k=0;k<2;k++) edgePts.push(scatter(p[0],p[1],0.06));
  }
  for(let i=0;i<N_center;i++){
    const p = basePts[(Math.random()*basePts.length)|0];
    centerPts.push(scatter(p[0],p[1],0.17));
  }
  for(let i=0;i<N_halo;i++){
    const t = Math.random()*Math.PI*2;
    let [x,y] = heart(t, scale*1.15);
    const cx=innerWidth/2, cy=innerHeight/2;
    const dx=x-cx, dy=y-cy;
    const force = 1 / (Math.pow(dx*dx+dy*dy, 0.6)+1e-6);
    const haloR = 8 + Math.random()*8;
    x -= haloR*force*dx + (Math.random()*24-12);
    y -= haloR*force*dy + (Math.random()*24-12);
    haloPts.push([x,y]);
  }
}
build();
addEventListener('resize', ()=>{ build(); });

// ---------- 动画 ----------
let frame=0, last=performance.now();
function loop(now){
  last = now; frame++;

  // 背景“柔擦”一层，留拖影
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = '#3b0018';
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // 发光设置（适度即可，过大很耗性能）
  ctx.globalAlpha = 1;
  ctx.fillStyle = COLOR;
  ctx.shadowColor = COLOR;
  ctx.shadowBlur  = 6;

  const ratio = 8 + Math.sin(frame/12)*8; // 心跳强度

  function draw(list){
    for(let i=0;i<list.length;i++){
      let [x,y] = list[i];
      [x,y] = pushOut(x,y, ratio);
      const s = Math.random()<0.5 ? 1 : 2;
      ctx.fillRect(x,y,s,s);
    }
  }
  // 先画光晕，再画主体
  draw(haloPts);
  draw(basePts);
  draw(edgePts);
  draw(centerPts);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>