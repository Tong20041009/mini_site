<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
<title>跳动的爱心 · Canvas</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
const cvs = document.getElementById('cv');
const ctx = cvs.getContext('2d', { alpha:false });
const COLOR = '#ff3ba7';            // 爱心颜色（可改）
const BG     = '#000';               // 背景黑色

// 高分屏自适应
function resize(){
  const dpr = Math.max(1, Math.min(2.5, devicePixelRatio||1));
  const w = innerWidth, h = innerHeight;
  cvs.style.width = w+'px'; cvs.style.height = h+'px';
  cvs.width = Math.floor(w*dpr); cvs.height = Math.floor(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', ()=>{ resize(); build(); });

// 心形参数方程（注意 y 取反，心向上）
function heart(t, scale){
  let x = 16 * Math.sin(t)**3;
  let y = -(13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t));
  x *= scale; y *= scale;
  return [x + innerWidth/2, y + innerHeight/2];
}
// 朝中心随机收缩
function scatter(x,y,beta){
  const cx=innerWidth/2, cy=innerHeight/2;
  const rx = -beta * Math.log(Math.random()+1e-6);
  const ry = -beta * Math.log(Math.random()+1e-6);
  return [x - rx*(x-cx), y - ry*(y-cy)];
}
// 心跳位移
function pushOut(x,y,ratio){
  const cx=innerWidth/2, cy=innerHeight/2;
  const dx=x-cx, dy=y-cy;
  const force = 1 / (Math.pow(dx*dx+dy*dy, 0.52)+1e-6);
  return [x - ratio*force*dx + (Math.random()*2-1),
          y - ratio*force*dy + (Math.random()*2-1)];
}

// 预生成粒子（按屏幕大小调数量，保证流畅）
let basePts=[], edgePts=[], centerPts=[], haloPts=[];
function build(){
  basePts = []; edgePts = []; centerPts = []; haloPts = [];
  const shortSide = Math.min(innerWidth, innerHeight);
  const scale = shortSide / 40;
  const density = shortSide < 700 ? 1.0 : 1.3;

  const N_base   = Math.floor(1200 * density);
  const N_edge   = Math.floor(1600 * density);
  const N_center = Math.floor(1600 * density);
  const N_halo   = Math.floor(1400 * density);

  for(let i=0;i<N_base;i++){
    const t = Math.random()*Math.PI*2;
    basePts.push(heart(t, scale*1.1));
  }
  for(const p of basePts){
    if(edgePts.length >= N_edge) break;
    for(let k=0;k<2;k++) edgePts.push(scatter(p[0],p[1],0.06));
  }
  for(let i=0;i<N_center;i++){
    const p = basePts[(Math.random()*basePts.length)|0];
    centerPts.push(scatter(p[0],p[1],0.17));
  }
  for(let i=0;i<N_halo;i++){
    const t = Math.random()*Math.PI*2;
    let [x,y] = heart(t, scale*1.15);
    const cx=innerWidth/2, cy=innerHeight/2, dx=x-cx, dy=y-cy;
    const force = 1 / (Math.pow(dx*dx+dy*dy, 0.6)+1e-6);
    const haloR = 8 + Math.random()*8;
    x -= haloR*force*dx + (Math.random()*24-12);
    y -= haloR*force*dy + (Math.random()*24-12);
    haloPts.push([x,y]);
  }
}
build();

// 动画
let frame=0;
function loop(){
  frame++;

  // 柔擦背景，留拖影
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = BG;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // 绘制设置
  ctx.globalAlpha = 1;
  ctx.fillStyle = COLOR;
  ctx.shadowColor = COLOR;
  ctx.shadowBlur  = 6;                 // 想更亮可调 8~10
  ctx.globalCompositeOperation = 'lighter';

  const ratio = 8 + Math.sin(frame/12)*8; // 心跳强度

  function draw(list){
    for(let i=0;i<list.length;i++){
      let [x,y] = list[i];
      [x,y] = pushOut(x,y, ratio);
      const s = Math.random()<0.5 ? 1 : 2;
      ctx.fillRect(x,y,s,s);
    }
  }
  draw(haloPts); draw(basePts); draw(edgePts); draw(centerPts);

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>